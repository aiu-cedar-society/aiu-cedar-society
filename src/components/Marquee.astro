---
interface Props {
  items: Array<{ name: string; logo?: string; url?: string }>;
  speed?: 'slow' | 'normal' | 'fast';
  direction?: 'left' | 'right';
  className?: string;
}

const { 
  items, 
  speed = 'normal', 
  direction = 'left',
  className = '' 
} = Astro.props;

// 速度は「px/秒」で固定（協賛数が増えて距離が伸びても体感速度を一定にする）
const pxPerSecMap = {
  slow: 15,
  normal: 30,
  fast: 45,
} as const;
---

<div class={`marquee-container ${className}`} data-marquee-container>
  <div
    class={`marquee-track marquee-${direction}`}
    data-marquee-track
    style={`--marquee-px-per-sec: ${pxPerSecMap[speed]}`}
  >
    <!-- 最初のセット -->
    <div class="marquee-content" data-marquee-base>
      {items.map((item) => (
        <div class="marquee-item">
          {item.logo ? (
            <img 
              src={`${item.logo}?w=240&fm=webp&q=80`}
              srcset={`
                ${item.logo}?w=120&fm=webp&q=80 120w,
                ${item.logo}?w=240&fm=webp&q=80 240w,
                ${item.logo}?w=360&fm=webp&q=80 360w
              `}
              sizes="(max-width: 640px) 120px, 240px"
              alt={item.name}
              class="marquee-logo"
              width="120"
              height="60"
              loading="lazy"
              decoding="async"
            />
          ) : (
            <span class="marquee-text">{item.name}</span>
          )}
        </div>
      ))}
    </div>
    <!-- 2セット目（シームレスループ用） -->
    <div class="marquee-content" aria-hidden="true">
      {items.map((item) => (
        <div class="marquee-item">
          {item.logo ? (
            <img 
              src={`${item.logo}?w=240&fm=webp&q=80`}
              srcset={`
                ${item.logo}?w=120&fm=webp&q=80 120w,
                ${item.logo}?w=240&fm=webp&q=80 240w,
                ${item.logo}?w=360&fm=webp&q=80 360w
              `}
              sizes="(max-width: 640px) 120px, 240px"
              alt=""
              class="marquee-logo"
              width="120"
              height="60"
              loading="lazy"
              decoding="async"
            />
          ) : (
            <span class="marquee-text">{item.name}</span>
          )}
        </div>
      ))}
    </div>
  </div>
</div>

<style>
  .marquee-container {
    --marquee-gap: 3rem;
    width: 100%;
    overflow: hidden;
    position: relative;
    padding: 2rem 0;
    background: linear-gradient(
      to right,
      rgba(255, 255, 255, 1) 0%,
      rgba(255, 255, 255, 0) 5%,
      rgba(255, 255, 255, 0) 95%,
      rgba(255, 255, 255, 1) 100%
    );
  }

  .marquee-track {
    display: flex;
    /* fit-content だと環境によって横幅計算が不安定になることがあるため max-content を使用 */
    width: max-content;
    transform: translate3d(0, 0, 0);
    /* 距離(px)から JS で duration(s) を計算して入れる */
    animation-duration: var(--marquee-duration, 20s);
    animation-timing-function: linear;
    animation-iteration-count: infinite;
  }

  /*
    Astro の scoped CSS は @keyframes 名を内部的にリネームすることがあります。
    animation-name を var() のフォールバックにすると書き換え対象から漏れて
    アニメーションが動かないケースがあるため、クラスで明示します。
  */
  .marquee-track.marquee-left {
    animation-name: marquee-left;
  }

  .marquee-track.marquee-right {
    animation-name: marquee-right;
  }

  .marquee-content {
    display: flex;
    gap: var(--marquee-gap);
    flex: 0 0 auto;
    /* セット末尾にも同じ間隔を含める（ループ境界の“間”をゼロにする） */
    padding-right: var(--marquee-gap);
  }

  .marquee-item {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    padding: 1rem 2rem;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    min-width: 200px;
  }

  .marquee-item:hover {
    transform: translateY(-4px);
    box-shadow: 0 4px 16px rgba(0, 104, 55, 0.15);
  }

  .marquee-logo {
    max-width: 120px;
    max-height: 60px;
    object-fit: contain;
    filter: grayscale(0.3);
    transition: filter 0.3s ease;
  }

  .marquee-item:hover .marquee-logo {
    filter: grayscale(0);
  }

  .marquee-text {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--color-gray-700, #374151);
    white-space: nowrap;
  }

  @keyframes marquee-left {
    0% {
      transform: translate3d(0, 0, 0);
    }
    100% {
      transform: translate3d(calc(-1 * var(--marquee-distance, 50%)), 0, 0);
    }
  }

  @keyframes marquee-right {
    0% {
      transform: translate3d(calc(-1 * var(--marquee-distance, 50%)), 0, 0);
    }
    100% {
      transform: translate3d(0, 0, 0);
    }
  }

  /* アクセシビリティ: 動きを減らす設定に対応 */
  @media (prefers-reduced-motion: reduce) {
    .marquee-track {
      animation: none;
    }
    
    .marquee-content {
      justify-content: center;
      flex-wrap: wrap;
    }
  }

  /* パフォーマンス最適化 */
  .marquee-track {
    will-change: transform;
  }
</style>

<script is:inline>
  // シームレスに見せるために、1セット分の幅(px)で移動距離を決め、
  // 画面幅を埋めるまでコンテンツを必要数だけ複製する
  // Defer initialization to reduce TBT and forced reflows
  (function() {
    function initMarquee() {
      const containers = document.querySelectorAll("[data-marquee-container]");

    containers.forEach((container) => {
      if (!(container instanceof HTMLElement)) return;
      if (container.dataset.marqueeInitialized === "true") return;
      container.dataset.marqueeInitialized = "true";

      const track = container.querySelector("[data-marquee-track]");
      const base = container.querySelector("[data-marquee-base]");
      if (!(track instanceof HTMLElement) || !(base instanceof HTMLElement)) return;

      let resizeObserver = null;
      let rafId = 0;
      let lastBaseWidth = 0;
      let lastContainerWidth = 0;

      const sync = () => {
        const containerRect = container.getBoundingClientRect();
        const containerWidth = Math.round(containerRect.width);
        // scrollWidth は padding を含み、transform の影響も受けにくい
        const baseWidth = Math.round(base.scrollWidth);
        if (!baseWidth || !containerWidth) return;

        // 幅が変わっていないなら DOM を触らない（触るとアニメが“巻き戻った”ように見えることがある）
        const sizeChanged =
          Math.abs(baseWidth - lastBaseWidth) > 1 ||
          Math.abs(containerWidth - lastContainerWidth) > 1;
        if (sizeChanged) {
          lastBaseWidth = baseWidth;
          lastContainerWidth = containerWidth;
          // 1セット分の幅を移動距離にする（% だと端末/画像読み込みでズレやすい）
          track.style.setProperty("--marquee-distance", `${baseWidth}px`);

          // 協賛数（=距離）に依存せず、速度(px/秒)が一定になるよう duration を計算
          const pxPerSecRaw = getComputedStyle(track)
            .getPropertyValue("--marquee-px-per-sec")
            .trim();
          const pxPerSec = Number.parseFloat(pxPerSecRaw) || 60;
          const durationSec = baseWidth / pxPerSec;
          track.style.setProperty("--marquee-duration", `${durationSec}s`);
        }

        // アニメーション中、常に画面が埋まるように必要セット数を計算
        // 条件: totalTrackWidth >= containerWidth + baseWidth
        const requiredSets = Math.max(2, Math.ceil((containerWidth + baseWidth) / baseWidth));

        const existingSets = track.querySelectorAll(".marquee-content").length;
        // 必要分だけ追加。減らす必要はない（削除するとアニメがリセットっぽく見えやすい）
        const needToAdd = Math.max(0, requiredSets - existingSets);

        for (let i = 0; i < needToAdd; i++) {
          const clone = base.cloneNode(true);
          if (!(clone instanceof HTMLElement)) continue;
          clone.setAttribute("aria-hidden", "true");
          clone.dataset.marqueeClone = "true";

          // クローンはスクリーンリーダー/タブ移動に入れない
          clone.querySelectorAll("a").forEach((a) => {
            a.setAttribute("tabindex", "-1");
          });
          clone.querySelectorAll("img").forEach((img) => {
            img.setAttribute("alt", "");
          });

          track.appendChild(clone);
        }
      };

      const scheduleSync = () => {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          rafId = 0;
          sync();
        });
      };

      // 画像読み込みで幅が変わるので、読み込み完了時にも再計算
      base.querySelectorAll("img").forEach((img) => {
        if (!(img instanceof HTMLImageElement)) return;
        if (img.complete) return;
        img.addEventListener("load", scheduleSync, { once: true });
        img.addEventListener("error", scheduleSync, { once: true });
      });

      // 初回 + リサイズ対応
      scheduleSync();
      window.addEventListener("resize", scheduleSync, { passive: true });
      if ("ResizeObserver" in window) {
        resizeObserver = new ResizeObserver(scheduleSync);
        resizeObserver.observe(container);
      }

      // ページ遷移前に後始末
      document.addEventListener(
        "astro:before-preparation",
        () => {
          window.removeEventListener("resize", scheduleSync);
          if (resizeObserver) resizeObserver.disconnect();
          if (rafId) cancelAnimationFrame(rafId);
        },
        { once: true },
      );
    });
    }
    
    // Defer initialization to reduce TBT
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(initMarquee, { timeout: 2000 });
        } else {
          setTimeout(initMarquee, 100);
        }
      });
    } else {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(initMarquee, { timeout: 2000 });
      } else {
        setTimeout(initMarquee, 100);
      }
    }
  })();
</script>



