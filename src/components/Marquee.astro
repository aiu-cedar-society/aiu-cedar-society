---
interface Props {
  items: Array<{ name: string; logo?: string; url?: string }>;
  speed?: 'slow' | 'normal' | 'fast';
  direction?: 'left' | 'right';
  className?: string;
}

const { 
  items, 
  speed = 'normal', 
  direction = 'left',
  className = '' 
} = Astro.props;

// 速度は「px/秒」で固定（協賛数が増えて距離が伸びても体感速度を一定にする）
const pxPerSecMap = {
  slow: 15,
  normal: 30,
  fast: 45,
} as const;
---

<div class={`marquee-container ${className}`} data-marquee-container>
  <div
    class={`marquee-track marquee-${direction}`}
    data-marquee-track
    style={`--marquee-px-per-sec: ${pxPerSecMap[speed]}`}
  >
    <!-- 最初のセット -->
    <div class="marquee-content" data-marquee-base>
      {items.map((item) => (
        <div class="marquee-item">
          {item.logo ? (
            <img 
              src={`${item.logo}?w=240&fm=webp&q=80`}
              srcset={`
                ${item.logo}?w=120&fm=webp&q=80 120w,
                ${item.logo}?w=240&fm=webp&q=80 240w,
                ${item.logo}?w=360&fm=webp&q=80 360w
              `}
              sizes="(max-width: 640px) 120px, 240px"
              alt={item.name}
              class="marquee-logo"
              width="120"
              height="60"
              loading="eager"
              decoding="async"
              fetchpriority="low"
            />
          ) : (
            <span class="marquee-text">{item.name}</span>
          )}
        </div>
      ))}
    </div>
    <!-- 2セット目（シームレスループ用） -->
    <div class="marquee-content" aria-hidden="true">
      {items.map((item) => (
        <div class="marquee-item">
          {item.logo ? (
            <img 
              src={`${item.logo}?w=240&fm=webp&q=80`}
              srcset={`
                ${item.logo}?w=120&fm=webp&q=80 120w,
                ${item.logo}?w=240&fm=webp&q=80 240w,
                ${item.logo}?w=360&fm=webp&q=80 360w
              `}
              sizes="(max-width: 640px) 120px, 240px"
              alt=""
              class="marquee-logo"
              width="120"
              height="60"
              loading="eager"
              decoding="async"
              fetchpriority="low"
            />
          ) : (
            <span class="marquee-text">{item.name}</span>
          )}
        </div>
      ))}
    </div>
  </div>
</div>

<style>
  .marquee-container {
    --marquee-gap: 3rem;
    width: 100%;
    overflow: hidden;
    position: relative;
    padding: 2rem 0;
    background: linear-gradient(
      to right,
      rgba(255, 255, 255, 1) 0%,
      rgba(255, 255, 255, 0) 5%,
      rgba(255, 255, 255, 0) 95%,
      rgba(255, 255, 255, 1) 100%
    );
  }

  .marquee-track {
    display: flex;
    /* fit-content だと環境によって横幅計算が不安定になることがあるため max-content を使用 */
    width: max-content;
    transform: translate3d(0, 0, 0);
    /* 距離(px)から JS で duration(s) を計算して入れる */
    animation-duration: var(--marquee-duration, 20s);
    animation-timing-function: linear;
    animation-iteration-count: infinite;
  }

  /*
    Astro の scoped CSS は @keyframes 名を内部的にリネームすることがあります。
    animation-name を var() のフォールバックにすると書き換え対象から漏れて
    アニメーションが動かないケースがあるため、クラスで明示します。
  */
  .marquee-track.marquee-left {
    animation-name: marquee-left;
  }

  .marquee-track.marquee-right {
    animation-name: marquee-right;
  }

  .marquee-content {
    display: flex;
    gap: var(--marquee-gap);
    flex: 0 0 auto;
    /* セット末尾にも同じ間隔を含める（ループ境界の“間”をゼロにする） */
    padding-right: var(--marquee-gap);
  }

  .marquee-item {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    padding: 1rem 2rem;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    min-width: 200px;
  }

  .marquee-item:hover {
    transform: translateY(-4px);
    box-shadow: 0 4px 16px rgba(0, 104, 55, 0.15);
  }

  .marquee-logo {
    max-width: 120px;
    max-height: 60px;
    object-fit: contain;
    filter: grayscale(0.3);
    transition: filter 0.3s ease;
  }

  .marquee-item:hover .marquee-logo {
    filter: grayscale(0);
  }

  .marquee-text {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--color-gray-700, #374151);
    white-space: nowrap;
  }

  @keyframes marquee-left {
    0% {
      transform: translate3d(0, 0, 0);
    }
    100% {
      transform: translate3d(calc(-1 * var(--marquee-distance, 50%)), 0, 0);
    }
  }

  @keyframes marquee-right {
    0% {
      transform: translate3d(calc(-1 * var(--marquee-distance, 50%)), 0, 0);
    }
    100% {
      transform: translate3d(0, 0, 0);
    }
  }

  /* アクセシビリティ: 動きを減らす設定に対応 */
  @media (prefers-reduced-motion: reduce) {
    .marquee-track {
      animation: none;
    }
    
    .marquee-content {
      justify-content: center;
      flex-wrap: wrap;
    }
  }

  /* パフォーマンス最適化 */
  .marquee-track {
    will-change: transform;
  }
</style>

<script is:inline>
  // シームレスに見せるために、1セット分の幅(px)で移動距離を決め、
  // 画面幅を埋めるまでコンテンツを必要数だけ複製する
  (function() {
    function initMarquee() {
      const containers = document.querySelectorAll("[data-marquee-container]");

      containers.forEach((container) => {
        if (!(container instanceof HTMLElement)) return;
        if (container.dataset.marqueeInitialized === "true") return;
        container.dataset.marqueeInitialized = "true";

        const track = container.querySelector("[data-marquee-track]");
        const base = container.querySelector("[data-marquee-base]");
        if (!(track instanceof HTMLElement) || !(base instanceof HTMLElement)) return;

        let resizeObserver = null;
        let rafId = 0;
        let lastBaseWidth = 0;
        let lastContainerWidth = 0;

        const sync = () => {
          const containerRect = container.getBoundingClientRect();
          const containerWidth = Math.round(containerRect.width);
          // scrollWidth は padding を含み、transform の影響も受けにくい
          const baseWidth = Math.round(base.scrollWidth);
          
          // 画像がまだ読み込まれていない場合は最小幅チェック
          // 各アイテムは min-width: 200px なので、アイテム数 × 200 以上あるべき
          const items = base.querySelectorAll(".marquee-item");
          const expectedMinWidth = items.length * 200;
          if (baseWidth < expectedMinWidth * 0.5) {
            // 幅が期待値の半分以下なら、まだ画像が読み込まれていない可能性が高い
            // 少し待ってから再試行
            setTimeout(sync, 100);
            return;
          }
          
          if (!baseWidth || !containerWidth) return;

          // 幅が変わっていないなら DOM を触らない（触るとアニメが"巻き戻った"ように見えることがある）
          const sizeChanged =
            Math.abs(baseWidth - lastBaseWidth) > 1 ||
            Math.abs(containerWidth - lastContainerWidth) > 1;
          if (sizeChanged) {
            lastBaseWidth = baseWidth;
            lastContainerWidth = containerWidth;
            // 1セット分の幅を移動距離にする（% だと端末/画像読み込みでズレやすい）
            track.style.setProperty("--marquee-distance", `${baseWidth}px`);

            // 協賛数（=距離）に依存せず、速度(px/秒)が一定になるよう duration を計算
            const pxPerSecRaw = getComputedStyle(track)
              .getPropertyValue("--marquee-px-per-sec")
              .trim();
            const pxPerSec = Number.parseFloat(pxPerSecRaw) || 60;
            const durationSec = baseWidth / pxPerSec;
            track.style.setProperty("--marquee-duration", `${durationSec}s`);
          }

          // アニメーション中、常に画面が埋まるように必要セット数を計算
          // 条件: totalTrackWidth >= containerWidth + baseWidth
          // 安全マージンとして +1 を追加
          const requiredSets = Math.max(3, Math.ceil((containerWidth + baseWidth) / baseWidth) + 1);

          const existingSets = track.querySelectorAll(".marquee-content").length;
          // 必要分だけ追加。減らす必要はない（削除するとアニメがリセットっぽく見えやすい）
          const needToAdd = Math.max(0, requiredSets - existingSets);

          for (let i = 0; i < needToAdd; i++) {
            const clone = base.cloneNode(true);
            if (!(clone instanceof HTMLElement)) continue;
            clone.setAttribute("aria-hidden", "true");
            clone.dataset.marqueeClone = "true";
            // クローンの data-marquee-base は削除して、base との混同を防ぐ
            delete clone.dataset.marqueeBase;

            // クローンはスクリーンリーダー/タブ移動に入れない
            clone.querySelectorAll("a").forEach((a) => {
              a.setAttribute("tabindex", "-1");
            });
            clone.querySelectorAll("img").forEach((img) => {
              img.setAttribute("alt", "");
            });

            track.appendChild(clone);
          }
        };

        const scheduleSync = () => {
          if (rafId) cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(() => {
            rafId = 0;
            sync();
          });
        };

        // 画像読み込みで幅が変わるので、読み込み完了時にも再計算
        const images = base.querySelectorAll("img");
        let loadedCount = 0;
        const totalImages = images.length;
        
        const onImageReady = () => {
          loadedCount++;
          scheduleSync();
          // すべての画像が読み込まれたら、最終的な再計算を行う
          if (loadedCount === totalImages) {
            setTimeout(scheduleSync, 50);
          }
        };
        
        images.forEach((img) => {
          if (!(img instanceof HTMLImageElement)) return;
          if (img.complete && img.naturalWidth > 0) {
            loadedCount++;
          } else {
            img.addEventListener("load", onImageReady, { once: true });
            img.addEventListener("error", onImageReady, { once: true });
          }
        });

        // 初回同期
        scheduleSync();
        
        // 画像がすべて読み込み済みの場合も、念のため遅延再計算
        if (loadedCount === totalImages) {
          setTimeout(scheduleSync, 100);
        }
        
        // リサイズ対応
        window.addEventListener("resize", scheduleSync, { passive: true });
        if ("ResizeObserver" in window) {
          resizeObserver = new ResizeObserver(scheduleSync);
          resizeObserver.observe(container);
        }

        // ページ遷移前に後始末
        document.addEventListener(
          "astro:before-preparation",
          () => {
            window.removeEventListener("resize", scheduleSync);
            if (resizeObserver) resizeObserver.disconnect();
            if (rafId) cancelAnimationFrame(rafId);
          },
          { once: true },
        );
      });
    }
    
    // DOMContentLoaded 後に初期化（画像の読み込みを待つ）
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        // 少し遅延させて、画像が読み込み開始されるのを待つ
        setTimeout(initMarquee, 50);
      });
    } else {
      // すでにDOMContentLoaded済みの場合
      setTimeout(initMarquee, 50);
    }
    
    // Astro のページ遷移後にも再初期化
    document.addEventListener('astro:page-load', function() {
      setTimeout(initMarquee, 50);
    });
  })();
</script>



